commit ea6bf2e49e29225f3c44fe399f77763cd82ca1f2
Author: Da Zheng <zhengda1936@gmail.com>
Date:   Sat Dec 26 14:54:55 2015 -0500

    [Matrix]: handle matrices with diff portion sizes in mapply serial.

diff --git a/matrix/dense_matrix.cpp b/matrix/dense_matrix.cpp
index 17872ab..963d266 100644
--- a/matrix/dense_matrix.cpp
+++ b/matrix/dense_matrix.cpp
@@ -1223,6 +1223,8 @@ public:
 		this->op = op;
 		this->num_required = num_required;
 		this->num_ready = 0;
+		for (size_t i = 1; i < res_mats.size(); i++)
+			assert(res_mats[0]->is_wide() == res_mats[i]->is_wide());
 	}
 
 	off_t get_global_start() const {
@@ -1235,7 +1237,18 @@ public:
 
 	void run_all_portions();
 
+	void create_portion(int node_id);
+	/*
+	 * There are two versions of add_ready_portion to handle matrices with
+	 * different portion sizes.
+	 * The first version handles the matrix with the portion size the same
+	 * as `length'.
+	 * The second version handles the matrix with a portion size, so we
+	 * process multiple portions whose total size is `length'.
+	 */
 	void add_ready_portion(local_matrix_store::const_ptr portion);
+	void add_ready_portion(
+			const std::vector<local_matrix_store::const_ptr> &portions);
 
 	bool is_complete() const {
 		return num_required == num_ready;
@@ -1412,6 +1425,32 @@ void EM_mat_mapply_par_dispatcher::create_task(off_t global_start,
 	}
 }
 
+void collected_portions::create_portion(int node_id)
+{
+	size_t start_row, start_col, num_rows, num_cols;
+	if (res_mats.front()->is_wide()) {
+		start_row = 0;
+		start_col = global_start;
+		num_rows = op->get_out_num_rows();
+		num_cols = length;
+	}
+	else {
+		start_row = global_start;
+		start_col = 0;
+		num_rows = length;
+		num_cols = op->get_out_num_cols();
+	}
+
+	if (res_mats.front()->store_layout() == matrix_layout_t::L_COL)
+		res_portion = local_matrix_store::ptr(
+				new local_buf_col_matrix_store(start_row, start_col,
+					num_rows, num_cols, op->get_output_type(), node_id));
+	else
+		res_portion = local_matrix_store::ptr(
+				new local_buf_row_matrix_store(start_row, start_col,
+					num_rows, num_cols, op->get_output_type(), node_id));
+}
+
 void collected_portions::add_ready_portion(local_matrix_store::const_ptr portion)
 {
 	num_ready++;
@@ -1430,31 +1469,7 @@ void collected_portions::add_ready_portion(local_matrix_store::const_ptr portion
 			// Regardless of the number of output matrices we want to generate
 			// eventually, we only use one matrix portion to store
 			// the intermediate aggregation result.
-			size_t start_row, start_col, num_rows, num_cols;
-			if (res_mats.front()->is_wide()) {
-				start_row = 0;
-				start_col = global_start;
-				num_rows = op->get_out_num_rows();
-				num_cols = length;
-			}
-			else {
-				start_row = global_start;
-				start_col = 0;
-				num_rows = length;
-				num_cols = op->get_out_num_cols();
-			}
-
-			if (res_mats.front()->store_layout() == matrix_layout_t::L_COL)
-				res_portion = local_matrix_store::ptr(
-						new local_buf_col_matrix_store(start_row, start_col,
-							num_rows, num_cols, op->get_output_type(),
-							portion->get_node_id()));
-			else
-				res_portion = local_matrix_store::ptr(
-						new local_buf_row_matrix_store(start_row, start_col,
-							num_rows, num_cols, op->get_output_type(),
-							portion->get_node_id()));
-
+			create_portion(portion->get_node_id());
 			std::vector<local_matrix_store::const_ptr> local_stores(1);
 			local_stores[0] = portion;
 			// We rely on the user-defined function to copy the first portion
@@ -1479,6 +1494,65 @@ void collected_portions::add_ready_portion(local_matrix_store::const_ptr portion
 	}
 }
 
+void collected_portions::add_ready_portion(
+		const std::vector<local_matrix_store::const_ptr> &portions)
+{
+	num_ready++;
+	assert(num_ready <= num_required);
+	assert(op->is_agg());
+
+	if (res_portion) {
+		std::vector<local_matrix_store::const_ptr> local_stores(2);
+		assert(!res_mats.empty());
+		bool is_wide = res_mats.front()->is_wide();
+		for (size_t i = 0; i < portions.size(); i++) {
+			if (is_wide)
+				res_portion->resize(0, portions.front()->get_num_cols() * i,
+						res_portion->get_num_rows(), portions[i]->get_num_cols());
+			else
+				res_portion->resize(portions.front()->get_num_rows() * i, 0,
+						portions[i]->get_num_rows(), res_portion->get_num_cols());
+			local_stores[0] = res_portion;
+			local_stores[1] = portions[i];
+			// We store the partial result in a single portion, regardless of
+			// the number of output matrices we want to generate eventually.
+			op->run(local_stores, *res_portion);
+		}
+		res_portion->reset_size();
+	}
+	else if (op->get_out_num_rows() > 0 && op->get_out_num_cols() > 0) {
+		// Regardless of the number of output matrices we want to generate
+		// eventually, we only use one matrix portion to store
+		// the intermediate aggregation result.
+		create_portion(portions.front()->get_node_id());
+		std::vector<local_matrix_store::const_ptr> local_stores(1);
+		assert(!res_mats.empty());
+		bool is_wide = res_mats.front()->is_wide();
+		for (size_t i = 0; i < portions.size(); i++) {
+			if (is_wide)
+				res_portion->resize(0, portions.front()->get_num_cols() * i,
+						res_portion->get_num_rows(), portions[i]->get_num_cols());
+			else
+				res_portion->resize(portions.front()->get_num_rows() * i, 0,
+						portions[i]->get_num_rows(), res_portion->get_num_cols());
+			local_stores[0] = portions[i];
+			// We rely on the user-defined function to copy the first portion
+			// to the partial result portion.
+			op->run(local_stores, *res_portion);
+		}
+		res_portion->reset_size();
+	}
+	else {
+		std::vector<local_matrix_store::const_ptr> local_stores(1);
+		for (size_t i = 0; i < portions.size(); i++) {
+			local_stores[0] = portions[i];
+			// We rely on the user-defined function to copy the first portion
+			// to the partial result portion.
+			op->run(local_stores);
+		}
+	}
+}
+
 void collected_portions::run_all_portions()
 {
 	assert(is_complete());
@@ -1545,29 +1619,65 @@ void serial_read_portion_compute::fetch_portion(
 		= new serial_read_portion_compute(collected);
 	serial_read_portion_compute::ptr compute(_compute);
 	size_t global_start_row, global_start_col, num_rows, num_cols;
+	std::vector<local_matrix_store::const_ptr> portions;
 	while (!mats.empty()) {
 		matrix_store::const_ptr mat = mats.front();
 		mats.pop_front();
+		size_t portion_size;
 		if (mat->is_wide()) {
 			global_start_row = 0;
 			global_start_col = collected->get_global_start();
 			num_rows = mat->get_num_rows();
 			num_cols = collected->get_length();
+			portion_size = mat->get_portion_size().second;
+			portions.resize(ceil(((double) num_cols) / portion_size));
 		}
 		else {
 			global_start_row = collected->get_global_start();
 			global_start_col = 0;
 			num_rows = collected->get_length();
 			num_cols = mat->get_num_cols();
+			portion_size = mat->get_portion_size().first;
+			portions.resize(ceil(((double) num_rows) / portion_size));
 		}
-		async_cres_t res = mat->get_portion_async(global_start_row,
-				global_start_col, num_rows, num_cols, compute);
-		if (!res.first) {
-			_compute->pending_portion = res.second;
-			break;
+		// If we are getting the max portion size.
+		if (portions.size() == 1) {
+			async_cres_t res = mat->get_portion_async(global_start_row,
+					global_start_col, num_rows, num_cols, compute);
+			if (!res.first) {
+				_compute->pending_portion = res.second;
+				break;
+			}
+			else
+				collected->add_ready_portion(res.second);
+		}
+		else {
+			// In this case, the matrix is stored in memory.
+			size_t sub_num_rows, sub_num_cols;
+			for (size_t i = 0; i < portions.size(); i++) {
+				if (mat->is_wide()) {
+					sub_num_rows = num_rows;
+					sub_num_cols = std::min(portion_size,
+							mat->get_num_cols() - global_start_col);
+				}
+				else {
+					sub_num_rows = std::min(portion_size,
+							mat->get_num_rows() - global_start_row);
+					sub_num_cols = num_cols;
+				}
+				printf("portion %ld: %ld, %ld, %ld, %ld\n", i, global_start_row,
+						global_start_col, sub_num_rows, sub_num_cols);
+				async_cres_t res = mat->get_portion_async(global_start_row,
+						global_start_col, sub_num_rows, sub_num_cols, compute);
+				assert(res.first);
+				portions[i] = res.second;
+				if (mat->is_wide())
+					global_start_col += portion_size;
+				else
+					global_start_row += portion_size;
+			}
+			collected->add_ready_portion(portions);
 		}
-		else
-			collected->add_ready_portion(res.second);
 	}
 	if (collected->is_complete()) {
 		// All portions are ready, we can perform computation now.
